<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcards ‚Äî Mobile</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .perspective-1000 { perspective: 1000px; }
        .card-flip-inner { transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1); transform-style: preserve-3d; }
        .flipped .card-flip-inner { transform: rotateY(180deg); }
        .card-face { backface-visibility: hidden; }
        .card-back { transform: rotateY(180deg); }

        /* Mobile adjustments */
    #flashcard-container { transition: transform 0.25s ease, opacity 0.25s ease; touch-action: pan-y; }
        #flashcard-container .card-face { padding: 1.25rem; }
        .card-front-text { font-size: 1.25rem; }
        .card-back-text { font-size: 1rem; }

        /* Slide Animations */
        .slide-in-right { animation: slideInRight 0.3s forwards cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        .slide-in-left { animation: slideInLeft 0.3s forwards cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        @keyframes slideInRight { from { transform: translateX(30px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
        @keyframes slideInLeft { from { transform: translateX(-30px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

    /* Prevent horizontal scroll on small viewports */
    html, body { overflow-x: hidden; }

    /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #f8fafc; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 8px; }
        /* Swipe hint overlay */
        .swipe-hint {
            position: fixed;
            left: 50%;
            top: 45%;
            transform: translate(-50%, -50%) scale(0.9);
            background: rgba(15, 23, 42, 0.8);
            color: #fff;
            padding: 0.6rem 0.9rem;
            border-radius: 999px;
            font-size: 1.25rem;
            z-index: 60;
            pointer-events: none;
            opacity: 0;
            transition: transform 180ms ease, opacity 180ms ease;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 18px rgba(2,6,23,0.3);
        }
        .swipe-hint.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-900 font-sans min-h-screen">

    <div id="app" class="max-w-xl mx-auto p-3">
        <header class="mb-6 flex items-center justify-between gap-2">
            <div>
                <h1 class="text-2xl font-extrabold text-slate-800 tracking-tight">Flashcard Lexicon</h1>
                <p class="text-slate-500 text-xs italic">Mobile view</p>
            </div>
            <div class="flex gap-2 items-center">
                <button onclick="viewController.showLibrary()" class="px-3 py-2 bg-white border border-slate-200 rounded-lg shadow-sm hover:bg-slate-50 text-xs">My Decks</button>
                <button onclick="modalController.open('deckModal')" class="px-3 py-2 bg-indigo-600 text-white rounded-lg shadow-md hover:bg-indigo-700 text-xs">+ Deck</button>
            </div>
        </header>

        <main id="main-content"></main>
    </div>

    <!-- Swipe hint overlay (appears briefly when swipe detected) -->
    <div id="swipe-hint" class="swipe-hint" aria-hidden="true"></div>

    <!-- Modals (same as desktop) -->
    <div id="deckModal" class="hidden fixed inset-0 bg-slate-900/50 backdrop-blur-sm z-50 flex items-center justify-center p-4">
        <div class="bg-white rounded-2xl shadow-xl max-w-md w-full p-6">
            <h2 class="text-xl font-bold mb-4 text-slate-800">Initialize New Deck</h2>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-slate-700 mb-1">Nomenclature (Title)</label>
                    <input type="text" id="deckTitleInput" class="w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-500 outline-none" placeholder="e.g., Advanced Linguistics">
                </div>
                <div>
                    <label class="block text-sm font-medium text-slate-700 mb-1">Description</label>
                    <textarea id="deckDescInput" class="w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-500 outline-none" placeholder="Brief summary..."></textarea>
                </div>
                <div class="flex justify-end gap-3 pt-2">
                    <button onclick="modalController.close('deckModal')" class="px-4 py-2 text-slate-600 hover:bg-slate-100 rounded-lg transition">Cancel</button>
                    <button onclick="dataManager.createDeck()" class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition">Create Deck</button>
                </div>
            </div>
        </div>
    </div>

    <div id="cardModal" class="hidden fixed inset-0 bg-slate-900/50 backdrop-blur-sm z-50 flex items-center justify-center p-4">
        <div class="bg-white rounded-2xl shadow-xl max-w-md w-full p-6">
            <h2 class="text-xl font-bold mb-4 text-slate-800">Append New Flashcard</h2>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-slate-700 mb-1">Prompt (Front)</label>
                    <textarea id="cardFrontInput" class="w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-500 outline-none" placeholder="Enter term..."></textarea>
                </div>
                <div>
                    <label class="block text-sm font-medium text-slate-700 mb-1">Resolution (Back)</label>
                    <textarea id="cardBackInput" class="w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-indigo-500 outline-none" placeholder="Enter definition..."></textarea>
                </div>
                <div class="flex justify-end gap-3 pt-2">
                    <button onclick="modalController.close('cardModal')" class="px-4 py-2 text-slate-600 hover:bg-slate-100 rounded-lg transition">Cancel</button>
                    <button onclick="dataManager.createCard()" class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition">Save Card</button>
                </div>
            </div>
        </div>
    </div>

    <div id="bulkModal" class="hidden fixed inset-0 bg-slate-900/50 backdrop-blur-sm z-50 flex items-center justify-center p-4">
        <div class="bg-white rounded-2xl shadow-xl max-w-2xl w-full p-6">
            <h2 class="text-xl font-bold mb-2 text-slate-800">Bulk Data Assimilation</h2>
            <p class="text-sm text-slate-500 mb-4">Standardized double-colon (::) delimiter.</p>
            <div class="space-y-4">
                <div class="bg-indigo-50 border border-indigo-100 p-4 rounded-xl flex justify-between items-center text-sm font-mono">
                    <code class="text-indigo-700">Question :: Answer</code>
                    <button onclick="dataManager.copyTemplate()" class="text-xs bg-white border border-indigo-200 text-indigo-600 px-3 py-1.5 rounded-lg font-bold">Copy Syntax</button>
                </div>
                <textarea id="bulkInput" class="w-full h-64 px-4 py-2 border border-slate-200 rounded-lg focus:ring-2 focus:ring-indigo-500 outline-none font-mono text-sm" placeholder="Flashcard :: Result"></textarea>
                <div class="flex justify-end gap-3 pt-2">
                    <button onclick="modalController.close('bulkModal')" class="px-4 py-2 text-slate-600 hover:bg-slate-100 rounded-lg transition">Cancel</button>
                    <button onclick="dataManager.processBulk()" class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition font-bold shadow-lg">Execute Import</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Reuse the same scripts and logic from desktop view with small mobile tweaks
        const state = {
            decks: [],
            currentDeckId: null,
            currentCardIndex: 0,
            lastAnimationDirection: 'right',
            exportMenuOpen: false
        };

        async function saveToStorage() {
            await fetch('/api/storage/flashcard_decks', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(state.decks)
            });
        }

        async function loadFromStorage() {
            const res = await fetch('/api/storage/flashcard_decks');
            const data = await res.json();
            state.decks = data || [];
        }

        window.addEventListener('click', (e) => {
            const dropdown = document.getElementById('export-menu');
            const button = document.getElementById('export-btn');
            if (state.exportMenuOpen && dropdown && !dropdown.contains(e.target) && !button.contains(e.target)) {
                state.exportMenuOpen = false;
                dropdown.classList.add('hidden');
            }
        });

        const viewController = {
            showLibrary: () => {
                state.currentDeckId = null;
                state.exportMenuOpen = false;
                const container = document.getElementById('main-content');
                if (state.decks.length === 0) {
                    container.innerHTML = `<div class="text-center py-10 bg-white rounded-3xl border-2 border-dashed border-slate-200"><div class="text-4xl mb-3">üóÇÔ∏è</div><h3 class="text-lg font-semibold text-slate-700">No Decks Manifested</h3><button onclick="modalController.open('deckModal')" class="mt-4 px-5 py-2 bg-indigo-600 text-white rounded-xl shadow-lg">Initialize First Deck</button></div>`;
                    return;
                }

                container.innerHTML = `<div class="space-y-4">${state.decks.map(deck => `
                    <div class="bg-white p-4 rounded-2xl shadow-sm border border-slate-100 hover:shadow-md transition cursor-pointer flex justify-between items-center" onclick="viewController.showDeck('${deck.id}')">
                        <div class="flex-1 pr-3"><h3 class="text-lg font-bold text-slate-800 truncate">${deck.title}</h3><p class="text-xs text-slate-500 truncate">${deck.description || 'No description.'}</p></div>
                        <div class="text-center"><span class="text-xs font-bold bg-indigo-50 text-indigo-600 px-2 py-1 rounded-full">${deck.cards.length}</span></div>
                    </div>`).join('')}</div>`;
            },

            toggleExportMenu: () => {
                const menu = document.getElementById('export-menu');
                state.exportMenuOpen = !state.exportMenuOpen;
                if (state.exportMenuOpen) menu.classList.remove('hidden'); else menu.classList.add('hidden');
            },

            showDeck: (deckId) => {
                state.currentDeckId = deckId;
                const deck = state.decks.find(d => d.id === deckId);
                const container = document.getElementById('main-content');
                const animationClass = state.lastAnimationDirection === 'right' ? 'slide-in-right' : 'slide-in-left';

                container.innerHTML = `
                    <div class="mb-4 flex items-center justify-between">
                        <div class="flex items-center gap-3">
                            <button onclick="viewController.showLibrary()" class="text-slate-500 hover:text-indigo-600 font-bold text-sm">‚Üê Back</button>
                            <h2 class="text-lg font-bold text-slate-800 truncate">${deck.title}</h2>
                        </div>
                        <div class="flex gap-2 items-center">
                            <button onclick="dataManager.shuffleDeck('${deck.id}')" class="text-xs font-bold text-amber-600 bg-amber-50 px-2 py-1.5 rounded-lg">Shuffle</button>
                            <button onclick="modalController.open('bulkModal')" class="text-xs font-bold text-indigo-600 bg-indigo-50 px-2 py-1.5 rounded-lg">Bulk</button>
                        </div>
                    </div>
                    <div>
                        ${deck.cards.length > 0 ? `
                            <div id="flashcard-container" class="perspective-1000 h-[60vh] cursor-pointer ${animationClass}" onclick="viewController.flipCard()">
                                <div class="card-flip-inner relative w-full h-full text-center">
                                    <div class="card-face absolute inset-0 bg-white rounded-3xl shadow-xl flex items-center justify-center p-6 border-b-4 border-indigo-500 overflow-y-auto">
                                        <p class="card-front-text text-lg font-medium text-slate-800">${deck.cards[state.currentCardIndex].front}</p>
                                    </div>
                                    <div class="card-face card-back absolute inset-0 bg-indigo-600 text-white rounded-3xl shadow-xl flex items-center justify-center p-6 overflow-y-auto">
                                        <p class="card-back-text text-sm leading-relaxed">${deck.cards[state.currentCardIndex].back}</p>
                                    </div>
                                </div>
                            </div>
                            <div class="mt-3 flex items-center justify-between bg-white p-3 rounded-xl shadow-sm">
                                <div class="flex gap-2">
                                    <button onclick="viewController.prevCard()" class="px-3 py-2 text-slate-600 hover:bg-slate-100 rounded-lg text-sm">Previous</button>
                                    <button onclick="viewController.resetToStart()" class="px-3 py-2 text-indigo-600 hover:bg-indigo-50 rounded-lg text-sm font-bold">Back to 1</button>
                                </div>
                                <span class="text-slate-500 font-mono text-sm">${state.currentCardIndex + 1} / ${deck.cards.length}</span>
                                <button onclick="viewController.nextCard()" class="px-3 py-2 text-slate-600 hover:bg-slate-100 rounded-lg text-sm">Next</button>
                            </div>
                        ` : `<div class="h-56 bg-slate-100 rounded-3xl flex flex-col items-center justify-center border-2 border-dashed border-slate-300 text-slate-500">Inventory vacant.</div>`}
                    </div>
                    <div class="mt-4 bg-white p-3 rounded-2xl shadow-sm border border-slate-100">
                        <h3 class="font-bold mb-2 text-slate-800 flex justify-between items-center">Inventory <button onclick="modalController.open('cardModal')" class="text-xs bg-indigo-600 text-white px-2 py-1 rounded">+ Add</button></h3>
                        <div class="max-h-48 overflow-y-auto space-y-2 pr-2">
                            ${deck.cards.map((card, idx) => `
                                <div class="text-xs p-3 bg-slate-50 rounded-lg border border-slate-100 group flex justify-between items-start cursor-pointer hover:border-indigo-200" onclick="state.lastAnimationDirection='right'; state.currentCardIndex = ${idx}; viewController.showDeck('${deck.id}')">
                                    <span class="truncate pr-2 ${state.currentCardIndex === idx ? 'text-indigo-600 font-bold' : 'text-slate-700'}">${card.front}</span>
                                    <button onclick="event.stopPropagation(); dataManager.deleteCard(${idx})" class="opacity-0 group-hover:opacity-100 text-red-400 hover:text-red-600 transition">‚úï</button>
                                </div>`).join('')}
                        </div>
                    </div>
                `;

                // Attach touch handlers for swipe navigation and tap-to-flip on mobile
                const cardEl = document.getElementById('flashcard-container');
                if (cardEl) {
                    let touchState = { startX: 0, startY: 0, startTime: 0, moved: false };
                    let touchHandled = false; // prevents synthetic click from double-toggling

                    cardEl.ontouchstart = (ev) => {
                        if (ev.touches && ev.touches.length === 1) {
                            touchState.startX = ev.touches[0].clientX;
                            touchState.startY = ev.touches[0].clientY;
                            touchState.startTime = Date.now();
                            touchState.moved = false;
                            touchHandled = false;
                        }
                    };

                    cardEl.ontouchmove = (ev) => {
                        // Only treat as a move if the finger actually displaced beyond a small threshold
                        if (ev.touches && ev.touches.length === 1) {
                            const mx = ev.touches[0].clientX - touchState.startX;
                            const my = ev.touches[0].clientY - touchState.startY;
                            if (Math.abs(mx) > 10 || Math.abs(my) > 10) touchState.moved = true;
                        }
                    };

                    // Click handler should be ignored if a touch just handled the action
                    cardEl.onclick = (e) => {
                        if (touchHandled) {
                            // ignore the synthetic click that often follows touch on mobile
                            touchHandled = false;
                            return;
                        }
                        viewController.flipCard();
                    };

                    cardEl.ontouchend = (ev) => {
                        const t = ev.changedTouches && ev.changedTouches[0];
                        if (!t) return;
                        const dx = t.clientX - touchState.startX;
                        const dy = t.clientY - touchState.startY;
                        const dt = Date.now() - touchState.startTime;
                        const absX = Math.abs(dx), absY = Math.abs(dy);

                        // Horizontal swipe threshold and direction
                        if (absX > 40 && absX > absY * 1.5) {
                            if (dx < 0) {
                                // swipe left -> next
                                showSwipeHint('left');
                                viewController.nextCard();
                            } else {
                                // swipe right -> previous
                                showSwipeHint('right');
                                viewController.prevCard();
                            }
                            touchHandled = true;
                        } else if (!touchState.moved && dt < 300 && absX < 10 && absY < 10) {
                            // treat as a quick tap -> flip
                            viewController.flipCard();
                            touchHandled = true;
                        }
                        // clear the handled flag after a short interval to allow normal clicks later
                        if (touchHandled) setTimeout(() => { touchHandled = false; }, 400);
                    };
                }

                state.exportMenuOpen = false;
            },

            nextCard: () => {
                const deck = state.decks.find(d => d.id === state.currentDeckId);
                if (deck && state.currentCardIndex < deck.cards.length - 1) { state.lastAnimationDirection = 'right'; state.currentCardIndex++; viewController.showDeck(state.currentDeckId); }
            },

            prevCard: () => {
                if (state.currentCardIndex > 0) { state.lastAnimationDirection = 'left'; state.currentCardIndex--; viewController.showDeck(state.currentDeckId); }
            },

            resetToStart: () => { state.lastAnimationDirection = 'left'; state.currentCardIndex = 0; viewController.showDeck(state.currentDeckId); },

            flipCard: () => { const card = document.getElementById('flashcard-container'); if (card) card.classList.toggle('flipped'); }
        };

        // Swipe hint helper
        let _swipeHintTimer = null;
        function showSwipeHint(direction) {
            const el = document.getElementById('swipe-hint');
            if (!el) return;
        // flip arrows: show right arrow when swiping left, and left arrow when swiping right
        el.textContent = direction === 'left' ? '‚Üí' : '‚Üê';
            el.classList.add('show');
            if (_swipeHintTimer) clearTimeout(_swipeHintTimer);
            _swipeHintTimer = setTimeout(() => { el.classList.remove('show'); _swipeHintTimer = null; }, 500);
        }

        const modalController = { open: (id) => document.getElementById(id).classList.remove('hidden'), close: (id) => document.getElementById(id).classList.add('hidden') };

        const dataManager = {
            createDeck: () => {
                const title = document.getElementById('deckTitleInput').value.trim();
                if (!title) return;
                state.decks.push({ id: Date.now().toString(), title, description: document.getElementById('deckDescInput').value.trim(), cards: [] });
                saveToStorage();
                modalController.close('deckModal');
                viewController.showLibrary();
            },

            deleteDeck: (id) => { if (confirm("Purge deck?")) { state.decks = state.decks.filter(d => d.id !== id); saveToStorage(); viewController.showLibrary(); } },

            shuffleDeck: (id) => { const deck = state.decks.find(d => d.id === id); if (!deck || deck.cards.length < 2) return; for (let i = deck.cards.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [deck.cards[i], deck.cards[j]] = [deck.cards[j], deck.cards[i]]; } state.currentCardIndex = 0; saveToStorage(); viewController.showDeck(id); },

            createCard: () => { const front = document.getElementById('cardFrontInput').value.trim(); const back = document.getElementById('cardBackInput').value.trim(); if (!front || !back) return; state.decks.find(d => d.id === state.currentDeckId).cards.push({ front, back }); saveToStorage(); modalController.close('cardModal'); viewController.showDeck(state.currentDeckId); },

            copyTemplate: () => { const text = "Concept :: Explanation"; const el = document.createElement('textarea'); el.value = text; document.body.appendChild(el); el.select(); document.execCommand('copy'); document.body.removeChild(el); },

            exportDeck: (deckId, questionsOnly = false) => {
                const deck = state.decks.find(d => d.id === deckId);
                if (!deck || deck.cards.length === 0) { alert("Empty decks cannot be exported."); return; }
                let exportString = "";
                if (questionsOnly) exportString = deck.cards.map(c => c.front).join('\n'); else exportString = deck.cards.map(c => `${c.front} :: ${c.back}`).join('\n');
                const el = document.createElement('textarea'); el.value = exportString; document.body.appendChild(el); el.select(); document.execCommand('copy'); document.body.removeChild(el);
                const type = questionsOnly ? "Questions" : "Full deck content";
                alert(`${type} copied to clipboard successfully.`);
                state.exportMenuOpen = false; document.getElementById('export-menu')?.classList.add('hidden');
            },

            processBulk: () => {
                const input = document.getElementById('bulkInput').value;
                const deck = state.decks.find(d => d.id === state.currentDeckId);
                const lines = input.split('\n').filter(l => l.trim() !== '');
                let count = 0;
                lines.forEach(line => {
                    if (line.includes('::')) {
                        const parts = line.split('::');
                        const front = parts[0].trim();
                        const back = parts.slice(1).join('::').trim();
                        if (front && back) { deck.cards.push({ front, back }); count++; }
                    }
                });
                if(count > 0) { saveToStorage(); modalController.close('bulkModal'); viewController.showDeck(state.currentDeckId); }
            },

            deleteCard: (idx) => { const deck = state.decks.find(d => d.id === state.currentDeckId); deck.cards.splice(idx, 1); state.currentCardIndex = Math.max(0, Math.min(state.currentCardIndex, deck.cards.length - 1)); saveToStorage(); viewController.showDeck(state.currentDeckId); }
        };

        window.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            if (!state.currentDeckId) return;
            if (e.code === 'Space') { e.preventDefault(); viewController.flipCard(); }
            if (e.code === 'ArrowRight') viewController.nextCard();
            if (e.code === 'ArrowLeft') viewController.prevCard();
        });

        window.onload = async () => { await loadFromStorage(); viewController.showLibrary(); };
    </script>
</body>
</html>
